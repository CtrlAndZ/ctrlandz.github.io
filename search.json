[{"title":"Mysql中load data infile加载数据时使用AES_ENCRYPT进行AES加密","path":"/2022/12/16/Mysql中load-data-infile加载数据时使用AES-ENCRYPT进行AES加密/","content":"在Mysql中使用load data infile命令可以快速大批量加载数据到表中 AES_ENCRYPT(value,key)是mysql自带的AES加密命令 如何在使用load data infile加载数据的同时对数据使用AES加密呢？ 通过阅读mysql提供的文档可以得到答案： MySQL :: MySQL 8.0 Reference Manual :: 13.2.9 LOAD DATA Statement 具体命令如下： 1234load data infile &#x27;文件路径&#x27;into table &#x27;表名&#x27;set &#x27;字段1&#x27; = AES_ENCRYPT(&#x27;字段1&#x27;, &#x27;密钥&#x27;), &#x27;字段2&#x27; = AES_ENCRYPT(&#x27;字段2&#x27;, &#x27;密钥&#x27;); 建议把密钥进行Hash会更安全： 1234load data infile &#x27;文件路径&#x27;into table &#x27;表名&#x27;set &#x27;字段1&#x27; = AES_ENCRYPT(&#x27;字段1&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512))), &#x27;字段2&#x27; = AES_ENCRYPT(&#x27;字段2&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512))); 解密查询： 123select AES_DECRYPT(&#x27;字段1&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512))), AES_DECRYPT(&#x27;字段2&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512)))from &#x27;表名&#x27;; 如果你是使用工具，一般上面的方式就能看到人类能读懂的数据，但如果你使用的是命令行工具，那可能需要做一下转化： 123select CAST(AES_DECRYPT(&#x27;字段1&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512))) AS CHAR(50)), CAST(AES_DECRYPT(&#x27;字段2&#x27;, UNHEX(SHA2(&#x27;密钥&#x27;,512))) AS CHAR(50))from &#x27;表名&#x27;; 注意：1.AES加密数据不能使用varchar类型存储，会报[HY000][1366] Incorrect string value: &#39;\\x89P\\xD76\\xC6$...&#39; for column的错误，可以换成varbinary类型。 2.如果表内本身存在数据也需要加密，那可以把字段类型先更换为varbinary，再使用update命令对数据进行加密更新"},{"title":"spring-data-elasticsearch使用search_after","path":"/2022/10/07/spring-data-elasticsearch使用search-after/","content":"最近防疫项目用到es做人员扫码快速检索能力，且es是集群部署，所以在深度分页这一块采用search_after的方式，项目采用spring-cloud开发，所以自然考虑使用spring-data-elasticsearch来操作es，过程中遇到一些坑，分享出来希望对大家有些帮助。 当然，先说正常的使用。引入依赖，这里直接使用starter12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt;&lt;/dependency&gt; application.properties123456789spring.application.name=springdataesdemo# 连接地址spring.elasticsearch.rest.uris=172.29.0.22:31853# 连接超时时间spring.elasticsearch.rest.connection-timeout=1000# 认证信息，有就填spring.elasticsearch.rest.password=123456spring.elasticsearch.rest.username=elasticserver.port=8082 实体类1234567891011121314151617181920212223242526272829package org.example.springdataelasticsearch.entity;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;/** * 记录实体类 */@Data@Document(indexName = &quot;record&quot;, createIndex = false)public class Record &#123; /** * 编号 */ @Id private String id; /** * 用户名 */ private String username; /** * 创建时间 */ @Field(name = &quot;create_time&quot;) private String createTime; 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package org.example.springdataelasticsearch;import org.example.springdataelasticsearch.entity.Record;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Sort;import org.springframework.data.elasticsearch.core.ElasticsearchOperations;import org.springframework.data.elasticsearch.core.SearchHit;import org.springframework.data.elasticsearch.core.SearchHits;import org.springframework.data.elasticsearch.core.query.Query;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;@SpringBootTestpublic class RecordTest &#123; @Autowired private ElasticsearchOperations operations; @Test void searchAfter()&#123; Query query = Query.findAll(); query.setPageable(PageRequest.of(0, 3)); query.addSort(Sort.by(Sort.Direction.ASC, &quot;create_time&quot;)); List&lt;Object&gt; searchAfter = null; List&lt;Record&gt; foundEntities = new ArrayList&lt;&gt;(); int index = 0; do &#123; query.setSearchAfter(searchAfter); SearchHits&lt;Record&gt; searchHits = operations.search(query, Record.class); if (index++ == 10 || searchHits.getSearchHits().isEmpty())&#123; break; &#125; foundEntities.addAll(searchHits.stream().map(SearchHit::getContent).collect(Collectors.toList())); searchAfter = searchHits.getSearchHit((int) (searchHits.getSearchHits().size() - 1)).getSortValues(); &#125;while (true); System.out.println(foundEntities); System.out.println(searchAfter); &#125;&#125; 至此翻页就可以正常使用了 下面是一些踩坑点1.通过观察spring-data-elasticsearch的源码可以知道search_after能力在4.2版本才开始支持，所以此版本之前Query类中是没有setSearchAfter()方法的，如果使用的是spring-boot-starter-data-elasticsearch，那要注意其中的spring-data-elasticsearch版本有没有到达4.2。源码位置：https://github.com/spring-projects/spring-data-elasticsearch/blob/4.2.x/src/main/java/org/springframework/data/elasticsearch/core/query/Query.java 12345678/** * Sets the setSearchAfter objects for this query. * * @param searchAfter the setSearchAfter objects. These are obtained with &#123;@link SearchHit#getSortValues()&#125; from a * search result. * @since 4.2 */ void setSearchAfter(@Nullable List&lt;Object&gt; searchAfter); 2.与Spring Boot版本对应错误导致spring-boot-starter-data-elasticsearch中spring-data-elasticsearch版本错误问题如果你的pom文件中继承的spring-boot-starter-parent版本小于2.5.0，那么哪怕你引入的spring-boot-starter-data-elasticsearch版本是2.7.x，spring-data-elasticsearch还是会低于4.2.x，导致Query类中是没有setSearchAfter()方法：可以通过将spring-boot-starter-parent的版本升级到2.5.x来解决这个问题，如果你的项目模块较多，或者什么原因升级版本有些麻烦，那么可以通过显示的添加指定版本的依赖来解决这个问题： 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;4.4.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 官方的版本对应关系图附上传送地址：https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#preface.versions"},{"title":"Spring boot中优雅的实现字典管理","path":"/2021/12/15/Spring-boot中优雅的实现字典管理/","content":"利用字典可以统一管理系统中的散落的状态，增强系统的整体性与逻辑性。在开发之前我先参考了网上些许资料，其中主要参考这篇文章：https://blog.csdn.net/qq_40065776/article/details/107403576这篇文章是采取AOP方式对响应信息进行处理，在响应体内增加一个 “变量名” + “Text” 格式的字段来对字典进行解释。个人认为这种方式有一定缺点，其一是代码繁琐了些，因为AOP处理部分的代码是新增的，所以会增加处理逻辑，对系统会增加一定的逻辑时长。在该文章评论区一位叫“汤同学”的网友列出了使用自定义序列化的方式来进行处理，个人认为这种思路会更加优雅且相对逻辑时长较短。只不过该同学提供的方式需要在字段上指定字典注解之外，还需要@JsonSerialize(using = DicSerializer.class)来指定字段序列化方式。这篇文章是对“汤同学”方式的补充，可以不写序列化注解。 1.建表主表12345678910CREATE TABLE `dict` ( `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;, `code` varchar(32) DEFAULT NULL COMMENT &#x27;编码&#x27;, `name` varchar(32) DEFAULT NULL COMMENT &#x27;名称&#x27;, `describe` varchar(64) DEFAULT NULL COMMENT &#x27;描述&#x27;, `status` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;状态（0--正常1--冻结）&#x27;, `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `create_user` varchar(50) DEFAULT NULL COMMENT &#x27;创建人&#x27;, `is_del` tinyint(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除状态（0，正常，1已删除）&#x27;,) 副表1234567CREATE TABLE `dict_detail` ( `id` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;, `dict_code` VARCHAR(32) DEFAULT NULL COMMENT &#x27;字典编码&#x27;, `code` VARCHAR(32) DEFAULT NULL COMMENT &#x27;编码&#x27;, `name` VARCHAR(32) DEFAULT NULL COMMENT &#x27;名称&#x27;, `sort` TINYINT NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;) 生成实体部分就不重复赘述了，这里表索引和表之间的关系没有表明，自己看情况处理。 2.字典注解1234567891011121314/** * 数据字典注解 * @author liujing */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Dict &#123; /** * 字典code */ String value();&#125; 实现自动的自定义序列化，也就是不需要在属性上指定序列化的方式 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 字典自定序列化类 */public class DictSerializer extends StdSerializer&lt;Object&gt; implements ContextualSerializer &#123; private static final long serialVersionUID = -6157558261755426448L; private String dictCode; public DictSerializer() &#123; super(Object.class); &#125; public DictSerializer(String dictCode) &#123; super(Object.class); this.dictCode = dictCode; &#125; @Override public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) &#123; Dict annotation = property.getAnnotation(Dict.class); return new DictSerializer(annotation.value()); &#125; @SneakyThrows @Override public void serialize(Object code, JsonGenerator gen, SerializerProvider provider) &#123; /* 获取键值对，这里我处理成map的方式返回给前端 这部分要自己处理，我这里是通过一个业务类从redis中获取字典 */ DictDetailService service = SpringUtil.getBean(DictDetailService.class); DictDetail detail = service.get(this.dictCode, String.valueOf(code)); DictResp resp = new DictResp(); if (detail != null)&#123; resp.setDictCode(detail.getDictCode()); resp.setCode(detail.getCode()); resp.setName(detail.getName()); &#125; gen.writeObject(resp); &#125;&#125; 1234567891011121314151617/** * 字典注解序列化拦截器 */@Componentpublic class DictSensitiveAnnotationIntrospector extends NopAnnotationIntrospector &#123; private static final long serialVersionUID = 1L; @Override public Object findSerializer(Annotated am) &#123; Dict dict = am.getAnnotation(Dict.class); if (dict != null)&#123; return DictSerializer.class; &#125; return null; &#125;&#125; 下面部分代码就是增加@Dict注解属性的序列化方式 123456789101112131415/** * 修改被@Dict注解标注的属性字典序列化方式 * @author liujing */@Configurationpublic class DictSerializerConfig &#123; @Resource private DictSensitiveAnnotationIntrospector dictSensitiveAnnotationIntrospector; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123; return builder -&gt; builder.annotationIntrospector(dictSensitiveAnnotationIntrospector);; &#125;&#125; 3.测试实体12345678910111213141516171819202122/** * 管理员实体类 * @author liujing * @since 2021-12-15 */@Datapublic class Admin implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 管理员编号 */ private Integer id; /** * 性别 */ @Dict(&quot;sys_gender&quot;) private Integer gender;&#125; 接口就不写了，直接显示结果，gender会被翻译成带描述信息的对象，当然也可以放更多信息，在于修改DictSerializer类中serialize方法的序列化结果对象内容。"},{"title":"在uniapp H5项目中使用腾讯地图sdk","path":"/2020/07/10/在uniapp-H5项目中使用腾讯地图sdk/","content":"这里主要针对的是H5，小程序或app都有现成的sdk可以使用；本人是用uniapp在做微信公众号的h5页面，其中需要把经纬度信息转化成文字描述的位置信息，在腾讯地图开发平台上申请了一个key，然后下载了一个微信小程序使用的微信小程序JavaScriptSDK v1.2但是这个sdk是为小程序设计的，所以在vue的h5中使用会有跨域问题，所以结合vue-jsonp对这个sdk做了一下修改，可以直接放入h5中使用。此方法不止在uniapp中可以使用，在所有H5项目中都可以 说明关于sdk怎么修改的我就不多说了，想了解的自己看源码，可以下载上面提供的原版对比查看，简单描述一句就是把sdk内使用的wx对象重写，替换了里面的request方法，使用vue-jsonp完成跨域 安装vue-jsonp既然是要使用vue-jsonp，那就要先安装 1npm install vue-jsonp 在main.js中引入 12import &#123; VueJsonp &#125; from &#x27;vue-jsonp&#x27;Vue.use(VueJsonp) 导入代码下面是我已经修改好的代码，复制到一个js文件放到自己的项目内，例如：qqmap-wx-jssdk.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138var vm = &#x27;&#x27;/** * 这里是重写部分 */var wx = &#123; request(obj)&#123; obj.data.output = &#x27;jsonp&#x27; vm.$jsonp(obj.url,obj.data) .then(json =&gt; &#123; if(json.status == 0)&#123; obj.success(json) &#125;else &#123; obj.fail(json) &#125; &#125;) .catch(err =&gt; &#123; obj.fail(err) &#125;) &#125;&#125;var ERROR_CONF = &#123; KEY_ERR: 311, KEY_ERR_MSG: &#x27;key格式错误&#x27;, PARAM_ERR: 310, PARAM_ERR_MSG: &#x27;请求参数信息有误&#x27;, SYSTEM_ERR: 600, SYSTEM_ERR_MSG: &#x27;系统错误&#x27;, WX_ERR_CODE: 1000, WX_OK_CODE: 200&#125;;var BASE_URL = &#x27;https://apis.map.qq.com/ws/&#x27;;var URL_SEARCH = BASE_URL + &#x27;place/v1/search&#x27;;var URL_SUGGESTION = BASE_URL + &#x27;place/v1/suggestion&#x27;;var URL_GET_GEOCODER = BASE_URL + &#x27;geocoder/v1/&#x27;;var URL_CITY_LIST = BASE_URL + &#x27;district/v1/list&#x27;;var URL_AREA_LIST = BASE_URL + &#x27;district/v1/getchildren&#x27;;var URL_DISTANCE = BASE_URL + &#x27;distance/v1/&#x27;;var URL_DIRECTION = BASE_URL + &#x27;direction/v1/&#x27;;var MODE = &#123; driving: &#x27;driving&#x27;, transit: &#x27;transit&#x27;&#125;;var EARTH_RADIUS = 6378136.49;var Utils = &#123; /** * md5加密方法 * 版权所有©2011 Sebastian Tschan，https：//blueimp.net */ safeAdd(x, y) &#123; var lsw = (x &amp; 0xffff) + (y &amp; 0xffff); var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xffff); &#125;, bitRotateLeft(num, cnt) &#123; return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt)); &#125;, md5cmn(q, a, b, x, s, t) &#123; return this.safeAdd(this.bitRotateLeft(this.safeAdd(this.safeAdd(a, q), this.safeAdd(x, t)), s), b); &#125;, md5ff(a, b, c, d, x, s, t) &#123; return this.md5cmn((b &amp; c) | (~b &amp; d), a, b, x, s, t); &#125;, md5gg(a, b, c, d, x, s, t) &#123; return this.md5cmn((b &amp; d) | (c &amp; ~d), a, b, x, s, t); &#125;, md5hh(a, b, c, d, x, s, t) &#123; return this.md5cmn(b ^ c ^ d, a, b, x, s, t); &#125;, md5ii(a, b, c, d, x, s, t) &#123; return this.md5cmn(c ^ (b | ~d), a, b, x, s, t); &#125;, binlMD5(x, len) &#123; /* append padding */ x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (len % 32); x[((len + 64) &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = len; var i; var olda; var oldb; var oldc; var oldd; var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; for (i = 0; i &lt; x.length; i += 16) &#123; olda = a; oldb = b; oldc = c; oldd = d; a = this.md5ff(a, b, c, d, x[i], 7, -680876936); d = this.md5ff(d, a, b, c, x[i + 1], 12, -389564586); c = this.md5ff(c, d, a, b, x[i + 2], 17, 606105819); b = this.md5ff(b, c, d, a, x[i + 3], 22, -1044525330); a = this.md5ff(a, b, c, d, x[i + 4], 7, -176418897); d = this.md5ff(d, a, b, c, x[i + 5], 12, 1200080426); c = this.md5ff(c, d, a, b, x[i + 6], 17, -1473231341); b = this.md5ff(b, c, d, a, x[i + 7], 22, -45705983); a = this.md5ff(a, b, c, d, x[i + 8], 7, 1770035416); d = this.md5ff(d, a, b, c, x[i + 9], 12, -1958414417); c = this.md5ff(c, d, a, b, x[i + 10], 17, -42063); b = this.md5ff(b, c, d, a, x[i + 11], 22, -1990404162); a = this.md5ff(a, b, c, d, x[i + 12], 7, 1804603682); d = this.md5ff(d, a, b, c, x[i + 13], 12, -40341101); c = this.md5ff(c, d, a, b, x[i + 14], 17, -1502002290); b = this.md5ff(b, c, d, a, x[i + 15], 22, 1236535329); a = this.md5gg(a, b, c, d, x[i + 1], 5, -165796510); d = this.md5gg(d, a, b, c, x[i + 6], 9, -1069501632); c = this.md5gg(c, d, a, b, x[i + 11], 14, 643717713); b = this.md5gg(b, c, d, a, x[i], 20, -373897302); a = this.md5gg(a, b, c, d, x[i + 5], 5, -701558691); d = this.md5gg(d, a, b, c, x[i + 10], 9, 38016083); c = this.md5gg(c, d, a, b, x[i + 15], 14, -660478335); b = this.md5gg(b, c, d, a, x[i + 4], 20, -405537848); a = this.md5gg(a, b, c, d, x[i + 9], 5, 568446438); d = this.md5gg(d, a, b, c, x[i + 14], 9, -1019803690); c = this.md5gg(c, d, a, b, x[i + 3], 14, -187363961); b = this.md5gg(b, c, d, a, x[i + 8], 20, 1163531501); a = this.md5gg(a, b, c, d, x[i + 13], 5, -1444681467); d = this.md5gg(d, a, b, c, x[i + 2], 9, -51403784); c = this.md5gg(c, d, a, b, x[i + 7], 14, 1735328473); b = this.md5gg(b, c, d, a, x[i + 12], 20, -1926607734); a = this.md5hh(a, b, c, d, x[i + 5], 4, -378558); d = this.md5hh(d, a, b, c, x[i + 8], 11, -2022574463); c = this.md5hh(c, d, a, b, x[i + 11], 16, 1839030562); b = this.md5hh(b, c, d, a, x[i + 14], 23, -35309556); a = this.md5hh(a, b, c, d, x[i + 1], 4, -1530992060); d = this.md5hh(d, a, b, c, x[i + 4], 11, 1272893353); c = this.md5hh(c, d, a, b, x[i + 7], 16, -155497632); b = this.md5hh(b, c, d, a, x[i + 10], 23, -1094730640); a = this.md5hh(a, b, c, d, x[i + 13], 4, 681279174); d = this.md5hh(d, a, b, c, x[i], 11, -358537222); c = this.md5hh(c, d, a, b, x[i + 3], 16, -722521979); b = this.md5hh(b, c, d, a, x[i + 6], 23, 76029189); a = this.md5hh(a, b, c, d, x[i + 9], 4, -640364487); d = this.md5hh(d, a, b, c, x[i + 12], 11, -421815835); c = this.md5hh(c, d, a, b, x[i + 15], 16, 530742520); b = this.md5hh(b, c, d, a, x[i + 2], 23, -995338651); a = this.md5ii(a, b, c, d, x[i], 6, -198630844); d = this.md5ii(d, a, b, c, x[i + 7], 10, 1126891415); c = this.md5ii(c, d, a, b, x[i + 14], 15, -1416354905); b = this.md5ii(b, c, d, a, x[i + 5], 21, -57434055); a = this.md5ii(a, b, c, d, x[i + 12], 6, 1700485571); d = this.md5ii(d, a, b, c, x[i + 3], 10, -1894986606); c = this.md5ii(c, d, a, b, x[i + 10], 15, -1051523); b = this.md5ii(b, c, d, a, x[i + 1], 21, -2054922799); a = this.md5ii(a, b, c, d, x[i + 8], 6, 1873313359); d = this.md5ii(d, a, b, c, x[i + 15], 10, -30611744); c = this.md5ii(c, d, a, b, x[i + 6], 15, -1560198380); b = this.md5ii(b, c, d, a, x[i + 13], 21, 1309151649); a = this.md5ii(a, b, c, d, x[i + 4], 6, -145523070); d = this.md5ii(d, a, b, c, x[i + 11], 10, -1120210379); c = this.md5ii(c, d, a, b, x[i + 2], 15, 718787259); b = this.md5ii(b, c, d, a, x[i + 9], 21, -343485551); a = this.safeAdd(a, olda); b = this.safeAdd(b, oldb); c = this.safeAdd(c, oldc); d = this.safeAdd(d, oldd); &#125; return [a, b, c, d]; &#125;, binl2rstr(input) &#123; var i; var output = &#x27;&#x27;; var length32 = input.length * 32; for (i = 0; i &lt; length32; i += 8) &#123; output += String.fromCharCode((input[i &gt;&gt; 5] &gt;&gt;&gt; (i % 32)) &amp; 0xff); &#125; return output; &#125;, rstr2binl(input) &#123; var i; var output = []; output[(input.length &gt;&gt; 2) - 1] = undefined; for (i = 0; i &lt; output.length; i += 1) &#123; output[i] = 0; &#125; var length8 = input.length * 8; for (i = 0; i &lt; length8; i += 8) &#123; output[i &gt;&gt; 5] |= (input.charCodeAt(i / 8) &amp; 0xff) &lt;&lt; (i % 32); &#125; return output; &#125;, rstrMD5(s) &#123; return this.binl2rstr(this.binlMD5(this.rstr2binl(s), s.length * 8)); &#125;, rstrHMACMD5(key, data) &#123; var i; var bkey = this.rstr2binl(key); var ipad = []; var opad = []; var hash; ipad[15] = opad[15] = undefined; if (bkey.length &gt; 16) &#123; bkey = this.binlMD5(bkey, key.length * 8); &#125; for (i = 0; i &lt; 16; i += 1) &#123; ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5c5c5c5c; &#125; hash = this.binlMD5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8); return this.binl2rstr(this.binlMD5(opad.concat(hash), 512 + 128)); &#125;, rstr2hex(input) &#123; var hexTab = &#x27;0123456789abcdef&#x27;; var output = &#x27;&#x27;; var x; var i; for (i = 0; i &lt; input.length; i += 1) &#123; x = input.charCodeAt(i); output += hexTab.charAt((x &gt;&gt;&gt; 4) &amp; 0x0f) + hexTab.charAt(x &amp; 0x0f); &#125; return output; &#125;, str2rstrUTF8(input) &#123; return unescape(encodeURIComponent(input)); &#125;, rawMD5(s) &#123; return this.rstrMD5(this.str2rstrUTF8(s)); &#125;, hexMD5(s) &#123; return this.rstr2hex(this.rawMD5(s)); &#125;, rawHMACMD5(k, d) &#123; return this.rstrHMACMD5(this.str2rstrUTF8(k), str2rstrUTF8(d)); &#125;, hexHMACMD5(k, d) &#123; return this.rstr2hex(this.rawHMACMD5(k, d)); &#125;, md5(string, key, raw) &#123; if (!key) &#123; if (!raw) &#123; return this.hexMD5(string); &#125; return this.rawMD5(string); &#125; if (!raw) &#123; return this.hexHMACMD5(key, string); &#125; return this.rawHMACMD5(key, string); &#125;, /** * 得到md5加密后的sig参数 * @param &#123;Object&#125; requestParam 接口参数 * @param &#123;String&#125; sk签名字符串 * @param &#123;String&#125; featrue 方法名 * @return 返回加密后的sig参数 */ getSig(requestParam, sk, feature, mode) &#123; var sig = null; var requestArr = []; Object.keys(requestParam).sort().forEach(function(key)&#123; requestArr.push(key + &#x27;=&#x27; + requestParam[key]); &#125;); if (feature == &#x27;search&#x27;) &#123; sig = &#x27;/ws/place/v1/search?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;suggest&#x27;) &#123; sig = &#x27;/ws/place/v1/suggestion?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;reverseGeocoder&#x27;) &#123; sig = &#x27;/ws/geocoder/v1/?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;geocoder&#x27;) &#123; sig = &#x27;/ws/geocoder/v1/?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;getCityList&#x27;) &#123; sig = &#x27;/ws/district/v1/list?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;getDistrictByCityId&#x27;) &#123; sig = &#x27;/ws/district/v1/getchildren?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;calculateDistance&#x27;) &#123; sig = &#x27;/ws/distance/v1/?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; if (feature == &#x27;direction&#x27;) &#123; sig = &#x27;/ws/direction/v1/&#x27; + mode + &#x27;?&#x27; + requestArr.join(&#x27;&amp;&#x27;) + sk; &#125; sig = this.md5(sig); return sig; &#125;, /** * 得到终点query字符串 * @param &#123;Array|String&#125; 检索数据 */ location2query(data) &#123; if (typeof data == &#x27;string&#x27;) &#123; return data; &#125; var query = &#x27;&#x27;; for (var i = 0; i &lt; data.length; i++) &#123; var d = data[i]; if (!!query) &#123; query += &#x27;;&#x27;; &#125; if (d.location) &#123; query = query + d.location.lat + &#x27;,&#x27; + d.location.lng; &#125; if (d.latitude &amp;&amp; d.longitude) &#123; query = query + d.latitude + &#x27;,&#x27; + d.longitude; &#125; &#125; return query; &#125;, /** * 计算角度 */ rad(d) &#123; return d * Math.PI / 180.0; &#125;, /** * 处理终点location数组 * @return 返回终点数组 */ getEndLocation(location)&#123; var to = location.split(&#x27;;&#x27;); var endLocation = []; for (var i = 0; i &lt; to.length; i++) &#123; endLocation.push(&#123; lat: parseFloat(to[i].split(&#x27;,&#x27;)[0]), lng: parseFloat(to[i].split(&#x27;,&#x27;)[1]) &#125;) &#125; return endLocation; &#125;, /** * 计算两点间直线距离 * @param a 表示纬度差 * @param b 表示经度差 * @return 返回的是距离，单位m */ getDistance(latFrom, lngFrom, latTo, lngTo) &#123; var radLatFrom = this.rad(latFrom); var radLatTo = this.rad(latTo); var a = radLatFrom - radLatTo; var b = this.rad(lngFrom) - this.rad(lngTo); var distance = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLatFrom) * Math.cos(radLatTo) * Math.pow(Math.sin(b / 2), 2))); distance = distance * EARTH_RADIUS; distance = Math.round(distance * 10000) / 10000; return parseFloat(distance.toFixed(0)); &#125;, /** * 使用微信接口进行定位 */ getWXLocation(success, fail, complete) &#123; wx.getLocation(&#123; type: &#x27;gcj02&#x27;, success: success, fail: fail, complete: complete &#125;); &#125;, /** * 获取location参数 */ getLocationParam(location) &#123; if (typeof location == &#x27;string&#x27;) &#123; var locationArr = location.split(&#x27;,&#x27;); if (locationArr.length === 2) &#123; location = &#123; latitude: location.split(&#x27;,&#x27;)[0], longitude: location.split(&#x27;,&#x27;)[1] &#125;; &#125; else &#123; location = &#123;&#125;; &#125; &#125; return location; &#125;, /** * 回调函数默认处理 */ polyfillParam(param) &#123; param.success = param.success || function () &#123; &#125;; param.fail = param.fail || function () &#123; &#125;; param.complete = param.complete || function () &#123; &#125;; &#125;, /** * 验证param对应的key值是否为空 * * @param &#123;Object&#125; param 接口参数 * @param &#123;String&#125; key 对应参数的key */ checkParamKeyEmpty(param, key) &#123; if (!param[key]) &#123; var errconf = this.buildErrorConfig(ERROR_CONF.PARAM_ERR, ERROR_CONF.PARAM_ERR_MSG + key +&#x27;参数格式有误&#x27;); param.fail(errconf); param.complete(errconf); return true; &#125; return false; &#125;, /** * 验证参数中是否存在检索词keyword * * @param &#123;Object&#125; param 接口参数 */ checkKeyword(param)&#123; return !this.checkParamKeyEmpty(param, &#x27;keyword&#x27;); &#125;, /** * 验证location值 * * @param &#123;Object&#125; param 接口参数 */ checkLocation(param) &#123; var location = this.getLocationParam(param.location); if (!location || !location.latitude || !location.longitude) &#123; var errconf = this.buildErrorConfig(ERROR_CONF.PARAM_ERR, ERROR_CONF.PARAM_ERR_MSG + &#x27; location参数格式有误&#x27;); param.fail(errconf); param.complete(errconf); return false; &#125; return true; &#125;, /** * 构造错误数据结构 * @param &#123;Number&#125; errCode 错误码 * @param &#123;Number&#125; errMsg 错误描述 */ buildErrorConfig(errCode, errMsg) &#123; return &#123; status: errCode, message: errMsg &#125;; &#125;, /** * * 数据处理函数 * 根据传入参数不同处理不同数据 * @param &#123;String&#125; feature 功能名称 * search 地点搜索 * suggest关键词提示 * reverseGeocoder逆地址解析 * geocoder地址解析 * getCityList获取城市列表：父集 * getDistrictByCityId获取区县列表：子集 * calculateDistance距离计算 * @param &#123;Object&#125; param 接口参数 * @param &#123;Object&#125; data 数据 */ handleData(param,data,feature)&#123; if (feature == &#x27;search&#x27;) &#123; var searchResult = data.data; var searchSimplify = []; for (var i = 0; i &lt; searchResult.length; i++) &#123; searchSimplify.push(&#123; id: searchResult[i].id || null, title: searchResult[i].title || null, latitude: searchResult[i].location &amp;&amp; searchResult[i].location.lat || null, longitude: searchResult[i].location &amp;&amp; searchResult[i].location.lng || null, address: searchResult[i].address || null, category: searchResult[i].category || null, tel: searchResult[i].tel || null, adcode: searchResult[i].ad_info &amp;&amp; searchResult[i].ad_info.adcode || null, city: searchResult[i].ad_info &amp;&amp; searchResult[i].ad_info.city || null, district: searchResult[i].ad_info &amp;&amp; searchResult[i].ad_info.district || null, province: searchResult[i].ad_info &amp;&amp; searchResult[i].ad_info.province || null &#125;) &#125; param.success(data, &#123; searchResult: searchResult, searchSimplify: searchSimplify &#125;) &#125; else if (feature == &#x27;suggest&#x27;) &#123; var suggestResult = data.data; var suggestSimplify = []; for (var i = 0; i &lt; suggestResult.length; i++) &#123; suggestSimplify.push(&#123; adcode: suggestResult[i].adcode || null, address: suggestResult[i].address || null, category: suggestResult[i].category || null, city: suggestResult[i].city || null, district: suggestResult[i].district || null, id: suggestResult[i].id || null, latitude: suggestResult[i].location &amp;&amp; suggestResult[i].location.lat || null, longitude: suggestResult[i].location &amp;&amp; suggestResult[i].location.lng || null, province: suggestResult[i].province || null, title: suggestResult[i].title || null, type: suggestResult[i].type || null &#125;) &#125; param.success(data, &#123; suggestResult: suggestResult, suggestSimplify: suggestSimplify &#125;) &#125; else if (feature == &#x27;reverseGeocoder&#x27;) &#123; var reverseGeocoderResult = data.result; var reverseGeocoderSimplify = &#123; address: reverseGeocoderResult.address || null, latitude: reverseGeocoderResult.location &amp;&amp; reverseGeocoderResult.location.lat || null, longitude: reverseGeocoderResult.location &amp;&amp; reverseGeocoderResult.location.lng || null, adcode: reverseGeocoderResult.ad_info &amp;&amp; reverseGeocoderResult.ad_info.adcode || null, city: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.city || null, district: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.district || null, nation: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.nation || null, province: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.province || null, street: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.street || null, street_number: reverseGeocoderResult.address_component &amp;&amp; reverseGeocoderResult.address_component.street_number || null, recommend: reverseGeocoderResult.formatted_addresses &amp;&amp; reverseGeocoderResult.formatted_addresses.recommend || null, rough: reverseGeocoderResult.formatted_addresses &amp;&amp; reverseGeocoderResult.formatted_addresses.rough || null &#125;; if (reverseGeocoderResult.pois) &#123;//判断是否返回周边poi var pois = reverseGeocoderResult.pois; var poisSimplify = []; for (var i = 0;i &lt; pois.length;i++) &#123; poisSimplify.push(&#123; id: pois[i].id || null, title: pois[i].title || null, latitude: pois[i].location &amp;&amp; pois[i].location.lat || null, longitude: pois[i].location &amp;&amp; pois[i].location.lng || null, address: pois[i].address || null, category: pois[i].category || null, adcode: pois[i].ad_info &amp;&amp; pois[i].ad_info.adcode || null, city: pois[i].ad_info &amp;&amp; pois[i].ad_info.city || null, district: pois[i].ad_info &amp;&amp; pois[i].ad_info.district || null, province: pois[i].ad_info &amp;&amp; pois[i].ad_info.province || null &#125;) &#125; param.success(data,&#123; reverseGeocoderResult: reverseGeocoderResult, reverseGeocoderSimplify: reverseGeocoderSimplify, pois: pois, poisSimplify: poisSimplify &#125;) &#125; else &#123; param.success(data, &#123; reverseGeocoderResult: reverseGeocoderResult, reverseGeocoderSimplify: reverseGeocoderSimplify &#125;) &#125; &#125; else if (feature == &#x27;geocoder&#x27;) &#123; var geocoderResult = data.result; var geocoderSimplify = &#123; title: geocoderResult.title || null, latitude: geocoderResult.location &amp;&amp; geocoderResult.location.lat || null, longitude: geocoderResult.location &amp;&amp; geocoderResult.location.lng || null, adcode: geocoderResult.ad_info &amp;&amp; geocoderResult.ad_info.adcode || null, province: geocoderResult.address_components &amp;&amp; geocoderResult.address_components.province || null, city: geocoderResult.address_components &amp;&amp; geocoderResult.address_components.city || null, district: geocoderResult.address_components &amp;&amp; geocoderResult.address_components.district || null, street: geocoderResult.address_components &amp;&amp; geocoderResult.address_components.street || null, street_number: geocoderResult.address_components &amp;&amp; geocoderResult.address_components.street_number || null, level: geocoderResult.level || null &#125;; param.success(data,&#123; geocoderResult: geocoderResult, geocoderSimplify: geocoderSimplify &#125;); &#125; else if (feature == &#x27;getCityList&#x27;) &#123; var provinceResult = data.result[0]; var cityResult = data.result[1]; var districtResult = data.result[2]; param.success(data,&#123; provinceResult: provinceResult, cityResult: cityResult, districtResult: districtResult &#125;); &#125; else if (feature == &#x27;getDistrictByCityId&#x27;) &#123; var districtByCity = data.result[0]; param.success(data, districtByCity); &#125; else if (feature == &#x27;calculateDistance&#x27;) &#123; var calculateDistanceResult = data.result.elements; var distance = []; for (var i = 0; i &lt; calculateDistanceResult.length; i++)&#123; distance.push(calculateDistanceResult[i].distance); &#125; param.success(data, &#123; calculateDistanceResult: calculateDistanceResult, distance: distance &#125;); &#125; else if (feature == &#x27;direction&#x27;) &#123; var direction = data.result.routes; param.success(data,direction); &#125; else &#123; param.success(data); &#125; &#125;, /** * 构造微信请求参数，公共属性处理 * * @param &#123;Object&#125; param 接口参数 * @param &#123;Object&#125; param 配置项 * @param &#123;String&#125; feature 方法名 */ buildWxRequestConfig(param, options, feature) &#123; var that = this; options.header = &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;; options.method = &#x27;GET&#x27;; options.success = function (res) &#123; var data = res; if (data.status === 0) &#123; that.handleData(param, data, feature); &#125; else &#123; param.fail(data); &#125; &#125;; options.fail = function (res) &#123; res.statusCode = ERROR_CONF.WX_ERR_CODE; param.fail(that.buildErrorConfig(ERROR_CONF.WX_ERR_CODE, res.errMsg)); &#125;; options.complete = function (res) &#123; var statusCode = +res.statusCode; switch(statusCode) &#123; case ERROR_CONF.WX_ERR_CODE: &#123; param.complete(that.buildErrorConfig(ERROR_CONF.WX_ERR_CODE, res.errMsg)); break; &#125; case ERROR_CONF.WX_OK_CODE: &#123; var data = res.data; if (data.status === 0) &#123; param.complete(data); &#125; else &#123; param.complete(that.buildErrorConfig(data.status, data.message)); &#125; break; &#125; default:&#123; param.complete(that.buildErrorConfig(ERROR_CONF.SYSTEM_ERR, ERROR_CONF.SYSTEM_ERR_MSG)); &#125; &#125; &#125;; return options; &#125;, /** * 处理用户参数是否传入坐标进行不同的处理 */ locationProcess(param, locationsuccess, locationfail, locationcomplete) &#123; var that = this; locationfail = locationfail || function (res) &#123; res.statusCode = ERROR_CONF.WX_ERR_CODE; param.fail(that.buildErrorConfig(ERROR_CONF.WX_ERR_CODE, res.errMsg)); &#125;; locationcomplete = locationcomplete || function (res) &#123; if (res.statusCode == ERROR_CONF.WX_ERR_CODE) &#123; param.complete(that.buildErrorConfig(ERROR_CONF.WX_ERR_CODE, res.errMsg)); &#125; &#125;; if (!param.location) &#123; that.getWXLocation(locationsuccess, locationfail, locationcomplete); &#125; else if (that.checkLocation(param)) &#123; var location = Utils.getLocationParam(param.location); locationsuccess(location); &#125; &#125;&#125;;class QQMapWX &#123; /** * 构造函数 * * @param &#123;Object&#125; options 接口参数,key 为必选参数 */ constructor(options) &#123; if (!options.key) &#123; throw Error(&#x27;key值不能为空&#x27;); &#125; vm = options.vm this.key = options.key; &#125;; /** * POI周边检索 * * @param &#123;Object&#125; options 接口参数对象 * * 参数对象结构可以参考 * @see http://lbs.qq.com/webservice_v1/guide-search.html */ search(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (!Utils.checkKeyword(options)) &#123; return; &#125; var requestParam = &#123; keyword: options.keyword, orderby: options.orderby || &#x27;_distance&#x27;, page_size: options.page_size || 10, page_index: options.page_index || 1, output: &#x27;json&#x27;, key: that.key &#125;; if (options.address_format) &#123; requestParam.address_format = options.address_format; &#125; if (options.filter) &#123; requestParam.filter = options.filter; &#125; var distance = options.distance || &quot;1000&quot;; var auto_extend = options.auto_extend || 1; var region = null; var rectangle = null; //判断城市限定参数 if (options.region) &#123; region = options.region; &#125; //矩形限定坐标(暂时只支持字符串格式) if (options.rectangle) &#123; rectangle = options.rectangle; &#125; var locationsuccess = function (result) &#123; if (region &amp;&amp; !rectangle) &#123; //城市限定参数拼接 requestParam.boundary = &quot;region(&quot; + region + &quot;,&quot; + auto_extend + &quot;,&quot; + result.latitude + &quot;,&quot; + result.longitude + &quot;)&quot;; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;search&#x27;); &#125; &#125; else if (rectangle &amp;&amp; !region) &#123; //矩形搜索 requestParam.boundary = &quot;rectangle(&quot; + rectangle + &quot;)&quot;; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;search&#x27;); &#125; &#125; else &#123; requestParam.boundary = &quot;nearby(&quot; + result.latitude + &quot;,&quot; + result.longitude + &quot;,&quot; + distance + &quot;,&quot; + auto_extend + &quot;)&quot;; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;search&#x27;); &#125; &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_SEARCH, data: requestParam &#125;, &#x27;search&#x27;)); &#125;; Utils.locationProcess(options, locationsuccess); &#125;; /** * sug模糊检索 * * @param &#123;Object&#125; options 接口参数对象 * * 参数对象结构可以参考 * http://lbs.qq.com/webservice_v1/guide-suggestion.html */ getSuggestion(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (!Utils.checkKeyword(options)) &#123; return; &#125; var requestParam = &#123; keyword: options.keyword, region: options.region || &#x27;全国&#x27;, region_fix: options.region_fix || 0, policy: options.policy || 0, page_size: options.page_size || 10,//控制显示条数 page_index: options.page_index || 1,//控制页数 get_subpois : options.get_subpois || 0,//返回子地点 output: &#x27;json&#x27;, key: that.key &#125;; //长地址 if (options.address_format) &#123; requestParam.address_format = options.address_format; &#125; //过滤 if (options.filter) &#123; requestParam.filter = options.filter; &#125; //排序 if (options.location) &#123; var locationsuccess = function (result) &#123; requestParam.location = result.latitude + &#x27;,&#x27; + result.longitude; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;suggest&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_SUGGESTION, data: requestParam &#125;, &quot;suggest&quot;)); &#125;; Utils.locationProcess(options, locationsuccess); &#125; else &#123; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;suggest&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_SUGGESTION, data: requestParam &#125;, &quot;suggest&quot;)); &#125; &#125;; /** * 逆地址解析 * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * http://lbs.qq.com/webservice_v1/guide-gcoder.html */ reverseGeocoder(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); var requestParam = &#123; coord_type: options.coord_type || 5, get_poi: options.get_poi || 0, output: &#x27;json&#x27;, key: that.key &#125;; if (options.poi_options) &#123; requestParam.poi_options = options.poi_options &#125; var locationsuccess = function (result) &#123; requestParam.location = result.latitude + &#x27;,&#x27; + result.longitude; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;reverseGeocoder&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_GET_GEOCODER, data: requestParam &#125;, &#x27;reverseGeocoder&#x27;)); &#125;; Utils.locationProcess(options, locationsuccess); &#125;; /** * 地址解析 * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * http://lbs.qq.com/webservice_v1/guide-geocoder.html */ geocoder(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (Utils.checkParamKeyEmpty(options, &#x27;address&#x27;)) &#123; return; &#125; var requestParam = &#123; address: options.address, output: &#x27;json&#x27;, key: that.key &#125;; //城市限定 if (options.region) &#123; requestParam.region = options.region; &#125; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;geocoder&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_GET_GEOCODER, data: requestParam &#125;,&#x27;geocoder&#x27;)); &#125;; /** * 获取城市列表 * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * http://lbs.qq.com/webservice_v1/guide-region.html */ getCityList(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); var requestParam = &#123; output: &#x27;json&#x27;, key: that.key &#125;; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;getCityList&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_CITY_LIST, data: requestParam &#125;,&#x27;getCityList&#x27;)); &#125;; /** * 获取对应城市ID的区县列表 * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * http://lbs.qq.com/webservice_v1/guide-region.html */ getDistrictByCityId(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (Utils.checkParamKeyEmpty(options, &#x27;id&#x27;)) &#123; return; &#125; var requestParam = &#123; id: options.id || &#x27;&#x27;, output: &#x27;json&#x27;, key: that.key &#125;; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;getDistrictByCityId&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_AREA_LIST, data: requestParam &#125;,&#x27;getDistrictByCityId&#x27;)); &#125;; /** * 用于单起点到多终点的路线距离(非直线距离)计算： * 支持两种距离计算方式：步行和驾车。 * 起点到终点最大限制直线距离10公里。 * * 新增直线距离计算。 * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * http://lbs.qq.com/webservice_v1/guide-distance.html */ calculateDistance(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (Utils.checkParamKeyEmpty(options, &#x27;to&#x27;)) &#123; return; &#125; var requestParam = &#123; mode: options.mode || &#x27;walking&#x27;, to: Utils.location2query(options.to), output: &#x27;json&#x27;, key: that.key &#125;; if (options.from) &#123; options.location = options.from; &#125; //计算直线距离 if(requestParam.mode == &#x27;straight&#x27;)&#123; var locationsuccess = function (result) &#123; var locationTo = Utils.getEndLocation(requestParam.to);//处理终点坐标 var data = &#123; message:&quot;query ok&quot;, result:&#123; elements:[] &#125;, status:0 &#125;; for (var i = 0; i &lt; locationTo.length; i++) &#123; data.result.elements.push(&#123;//将坐标存入 distance: Utils.getDistance(result.latitude, result.longitude, locationTo[i].lat, locationTo[i].lng), duration:0, from:&#123; lat: result.latitude, lng:result.longitude &#125;, to:&#123; lat: locationTo[i].lat, lng: locationTo[i].lng &#125; &#125;); &#125; var calculateResult = data.result.elements; var distanceResult = []; for (var i = 0; i &lt; calculateResult.length; i++) &#123; distanceResult.push(calculateResult[i].distance); &#125; return options.success(data,&#123; calculateResult: calculateResult, distanceResult: distanceResult &#125;); &#125;; Utils.locationProcess(options, locationsuccess); &#125; else &#123; var locationsuccess = function (result) &#123; requestParam.from = result.latitude + &#x27;,&#x27; + result.longitude; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;calculateDistance&#x27;); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: URL_DISTANCE, data: requestParam &#125;,&#x27;calculateDistance&#x27;)); &#125;; Utils.locationProcess(options, locationsuccess); &#125; &#125;; /** * 路线规划： * * @param &#123;Object&#125; options 接口参数对象 * * 请求参数结构可以参考 * https://lbs.qq.com/webservice_v1/guide-road.html */ direction(options) &#123; var that = this; options = options || &#123;&#125;; Utils.polyfillParam(options); if (Utils.checkParamKeyEmpty(options, &#x27;to&#x27;)) &#123; return; &#125; var requestParam = &#123; output: &#x27;json&#x27;, key: that.key &#125;; //to格式处理 if (typeof options.to == &#x27;string&#x27;) &#123; requestParam.to = options.to; &#125; else &#123; requestParam.to = options.to.latitude + &#x27;,&#x27; + options.to.longitude; &#125; //初始化局部请求域名 var SET_URL_DIRECTION = null; //设置默认mode属性 options.mode = options.mode || MODE.driving; //设置请求域名 SET_URL_DIRECTION = URL_DIRECTION + options.mode; if (options.from) &#123; options.location = options.from; &#125; if (options.mode == MODE.driving) &#123; if (options.from_poi) &#123; requestParam.from_poi = options.from_poi; &#125; if (options.heading) &#123; requestParam.heading = options.heading; &#125; if (options.speed) &#123; requestParam.speed = options.speed; &#125; if (options.accuracy) &#123; requestParam.accuracy = options.accuracy; &#125; if (options.road_type) &#123; requestParam.road_type = options.road_type; &#125; if (options.to_poi) &#123; requestParam.to_poi = options.to_poi; &#125; if (options.from_track) &#123; requestParam.from_track = options.from_track; &#125; if (options.waypoints) &#123; requestParam.waypoints = options.waypoints; &#125; if (options.policy) &#123; requestParam.policy = options.policy; &#125; if (options.plate_number) &#123; requestParam.plate_number = options.plate_number; &#125; &#125; if (options.mode == MODE.transit) &#123; if (options.departure_time) &#123; requestParam.departure_time = options.departure_time; &#125; if (options.policy) &#123; requestParam.policy = options.policy; &#125; &#125; var locationsuccess = function (result) &#123; requestParam.from = result.latitude + &#x27;,&#x27; + result.longitude; if (options.sig) &#123; requestParam.sig = Utils.getSig(requestParam, options.sig, &#x27;direction&#x27;,options.mode); &#125; wx.request(Utils.buildWxRequestConfig(options, &#123; url: SET_URL_DIRECTION, data: requestParam &#125;, &#x27;direction&#x27;)); &#125;; Utils.locationProcess(options, locationsuccess); &#125;&#125;;module.exports = QQMapWX; 使用在需要使用的vue页面中导入刚刚复制下来的js文件 1import QQMapWX from &#x27;@/common/qqmap-wx-jssdk.js&#x27; 构造地图API对象 12345data() &#123; return &#123; qqMap: new QQMapWX(&#123;key: &#x27;你申请的KEY&#x27;,vm: this&#125;) &#125;&#125; 调用方法，例： 123456789this.qqMap.reverseGeocoder(&#123; location: &#123; latitude: _this.center.lat, longitude: _this.center.lng &#125;, success: function(res)&#123; console.log(res) &#125;&#125;) 项目Demogithub: https://github.com/CtrlAndZ/uni-txmap gitee: https://gitee.com/gitliujing/uni-txmap"},{"title":"运行 seata-server","path":"/wiki/seata/index.html","content":"docker-compose.yaml这里采用 docker-compose方式启动，其余方式大同小异，docker会更加干净方便，docker-compose.yaml文件内容如下： 123456789101112131415161718version: &quot;3&quot;services: seata-server: image: seataio/seata-server hostname: seata-server ports: - &quot;8091:8091&quot; - &quot;7091:7091&quot; environment: # 存储模式 用来存储全局事务、全局锁等数据 这里设置为db，可选的方式有file、db、redis - STORE_MODE=db - SEATA_PORT=8091 volumes: - &quot;/usr/share/zoneinfo/Asia/Shanghai:/etc/localtime&quot; #设置系统时区 - &quot;/usr/share/zoneinfo/Asia/Shanghai:/etc/timezone&quot; #设置时区 # 这个文件夹中的信息是seata项目本身的，由于这里使用的是docker容器方式 # 所以可以先启动一个seata容器，利用docker cp 命令将这个文件夹拷贝出来再映射好后重新启动 - &quot;./resources:/seata-server/resources&quot; application.yml从容器中cp出resources目录后，在其下面有application.yml和application.example.yml两个文件，其中第二个是示例，包括了所有的配置项，第一个是实际运行的配置文件，application.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server: port: 7091spring: application: name: seata-serverlogging: config: classpath:logback-spring.xml file: path: $&#123;user.home&#125;/logs/seata extend: logstash-appender: destination: 127.0.0.1:4560 kafka-appender: bootstrap-servers: 127.0.0.1:9092 topic: logback_to_logstashconsole: user: username: seata password: seataseata: config: # support: nacos, consul, apollo, zk, etcd3 type: nacos nacos: server-addr: 192.168.3.233:8848 namespace: group: SEATA_GROUP username: password: data-id: seataServer.properties registry: # support: nacos, eureka, redis, zk, consul, etcd3, sofa type: nacos nacos: application: seata-server server-addr: 192.168.3.233:8848 group: SEATA_GROUP namespace: cluster: default security: secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017 tokenValidityInMilliseconds: 1800000 ignore: urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login nacos - seataServer.propertiesnacos中添加配置，Data-id：seataServer.properties，Group：SEATA_GROUP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647store.mode=db#-----db-----store.db.datasource=druidstore.db.dbType=mysql# 需要根据mysql的版本调整driverClassName# mysql8及以上版本对应的driver：com.mysql.cj.jdbc.Driver# mysql8以下版本的driver：com.mysql.jdbc.Driverstore.db.driverClassName=com.mysql.cj.jdbc.Driverstore.db.url=jdbc:mysql://192.168.3.233:3306/seata-server?useUnicode=true&amp;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=falsestore.db.user=rootstore.db.password=@liujing# 数据库初始连接数store.db.minConn=1# 数据库最大连接数store.db.maxConn=20# 获取连接时最大等待时间 默认5000，单位毫秒store.db.maxWait=5000# 全局事务表名 默认global_tablestore.db.globalTable=global_table# 分支事务表名 默认branch_tablestore.db.branchTable=branch_table# 全局锁表名 默认lock_tablestore.db.lockTable=lock_table# 分发锁表名store.db.distributedLockTable=distributed_lock# 查询全局事务一次的最大条数 默认100store.db.queryLimit=100# undo保留天数 默认7天,log_status=1（附录3）和未正常清理的undoserver.undo.logSaveDays=7# undo清理线程间隔时间 默认86400000，单位毫秒server.undo.logDeletePeriod=86400000# 二阶段提交重试超时时长 单位ms,s,m,h,d,对应毫秒,秒,分,小时,天,默认毫秒。默认值-1表示无限重试# 公式: timeout&gt;=now-globalTransactionBeginTime,true表示超时则不再重试# 注: 达到超时时间后将不会做任何重试,有数据不一致风险,除非业务自行可校准数据,否者慎用server.maxCommitRetryTimeout=-1# 二阶段回滚重试超时时长server.maxRollbackRetryTimeout=-1# 二阶段提交未完成状态全局事务重试提交线程间隔时间 默认1000，单位毫秒server.recovery.committingRetryPeriod=1000# 二阶段异步提交状态重试提交线程间隔时间 默认1000，单位毫秒server.recovery.asynCommittingRetryPeriod=1000# 二阶段回滚状态重试回滚线程间隔时间 默认1000，单位毫秒server.recovery.rollbackingRetryPeriod=1000# 超时状态检测重试线程间隔时间 默认1000，单位毫秒，检测出超时将全局事务置入回滚会话管理器server.recovery.timeoutRetryPeriod=1000 建表由于这里采用的是db模式，db目前支持mysql、oracle、postgresql，所以需要初始化数据库，数据库名称叫做：seata-server，当然也可以自定义，不过上面的配置就要对应调整，这里采用mysql，mysql建表语句如下，其余的类型详见官方 [建表脚本] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- -------------------------------- The script used when storeMode is &#x27;db&#x27; ---------------------------------- the table to store GlobalSession dataCREATE TABLE IF NOT EXISTS `global_table`( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store BranchSession dataCREATE TABLE IF NOT EXISTS `branch_table`( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store lock dataCREATE TABLE IF NOT EXISTS `lock_table`( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0:locked ,1:rollbacking&#x27;, `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `distributed_lock`( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;AsyncCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryRollbacking&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;TxTimeoutCheck&#x27;, &#x27; &#x27;, 0); 启动至此stata-server端基本配置完成，在docker-compose.yaml同级目录执行docker-compose up -d启动程序，无错误日志则表示成功。"},{"title":"流程图","path":"/wiki/seata/chart.html","content":"graph TB A[源码入口spring.factories] --> SeataAutoConfiguration --> GT{GlobalTransactionScanner} GT --> D[\"实现InitializingBean接口实现afterPropertiesSet()\"] --> F{\"initClient()\"} F --> IT(init TM) F --> IR(init RM) GT --> H[\"继承AbstractAutoProxyCreator重写wrapIfNecessary()\"] --> I[\"GlobalTransactionalInterceptor.invoke()\"] U((用户)) --> I --> IH[\"GlobalTransactionalInterceptor.handleGlobalTransaction(methodInvocation, transactional)构建事务信息\"] IH --> TE[\"transactionalTemplate.execute()\"] --> BT[\"beginTransaction(txInfo, tx)开启事务\"] BT --> BE[\"business.execute()执行业务\"] --> CT[\"commitTransaction(tx)提交事务\"] BE --> CR[\"rollbackTransaction(tx, originalException)回滚事务\"] A --> SeataDataSourceAutoConfiguration --> SeataAutoDataSourceProxyCreator"},{"title":"运行官方示例","path":"/wiki/seata/samples.html","content":"下载&amp;配置先下载官方提供的示例代码：seata-samples 代码下载下来后内部是包含了多种方式的示例，这里我们使用的是nacos + mysql + spring的方式，所以选择springcloud-nacos-seata示例进行测试，在项目跟路径下maven的配置文件pom.xml下的modules中将springcloud-nacos-seata的注释去除。 1234567......&lt;modules&gt; ...... &lt;module&gt;springcloud-nacos-seata&lt;/module&gt; ......&lt;/modules&gt;...... 修改order-service和stock-service各自application.properties中的配置信息为自己的信息。 建表数据库自己随便建一个，名称与上面项目中数据库配置信息要对应 我们这里采用AT模式，所以需要建立UNDO_LOG表，其目的是用于二阶段中的回滚。 1234567891011121314-- 注意此处0.3.0+ 增加唯一索引 ux_undo_logCREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 另外两个示例需要的业务表 12345678910111213141516171819DROP TABLE IF EXISTS `storage_tbl`;CREATE TABLE `storage_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, PRIMARY KEY (`id`), UNIQUE KEY (`commodity_code`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `order_tbl`;CREATE TABLE `order_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 启动分别运行StockServiceApplication与OrderServiceApplication，如果启动遇到下面这个异常，那么在启动参数中添加--add-opens=java.base/java.lang=ALL-UNNAMED 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556572022-09-20 16:32:29.936 ERROR 38453 --- [ main] o.s.boot.SpringApplication : Application run failedorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;globalTransactionScanner&#x27; defined in class path resource [io/seata/spring/boot/autoconfigure/SeataAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [io.seata.spring.annotation.GlobalTransactionScanner]: Factory method &#x27;globalTransactionScanner&#x27; threw exception; nested exception is java.lang.ExceptionInInitializerError at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:657) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:637) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1176) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:229) ~[spring-context-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:723) ~[spring-context-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:536) ~[spring-context-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:405) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) ~[spring-boot-2.2.12.RELEASE.jar:2.2.12.RELEASE] at com.work.stock.StockServiceApplication.main(StockServiceApplication.java:30) ~[classes/:na]Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [io.seata.spring.annotation.GlobalTransactionScanner]: Factory method &#x27;globalTransactionScanner&#x27; threw exception; nested exception is java.lang.ExceptionInInitializerError at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:652) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] ... 19 common frames omittedCaused by: java.lang.ExceptionInInitializerError: null at net.sf.cglib.core.KeyFactory$Generator.generateClass(KeyFactory.java:166) ~[cglib-3.1.jar:na] at net.sf.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25) ~[cglib-3.1.jar:na] at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:216) ~[cglib-3.1.jar:na] at net.sf.cglib.core.KeyFactory$Generator.create(KeyFactory.java:144) ~[cglib-3.1.jar:na] at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:116) ~[cglib-3.1.jar:na] at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:108) ~[cglib-3.1.jar:na] at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:104) ~[cglib-3.1.jar:na] at net.sf.cglib.proxy.Enhancer.&lt;clinit&gt;(Enhancer.java:69) ~[cglib-3.1.jar:na] at io.seata.config.ConfigurationCache.proxy(ConfigurationCache.java:88) ~[seata-all-1.4.2.jar:1.4.2] at io.seata.config.ConfigurationFactory.buildConfiguration(ConfigurationFactory.java:136) ~[seata-all-1.4.2.jar:1.4.2] at io.seata.config.ConfigurationFactory.getInstance(ConfigurationFactory.java:94) ~[seata-all-1.4.2.jar:1.4.2] at io.seata.spring.annotation.GlobalTransactionScanner.&lt;init&gt;(GlobalTransactionScanner.java:87) ~[seata-all-1.4.2.jar:1.4.2] at io.seata.spring.annotation.GlobalTransactionScanner.&lt;init&gt;(GlobalTransactionScanner.java:143) ~[seata-all-1.4.2.jar:1.4.2] at io.seata.spring.boot.autoconfigure.SeataAutoConfiguration.globalTransactionScanner(SeataAutoConfiguration.java:55) ~[seata-spring-boot-starter-1.4.2.jar:na] at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na] at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na] at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.2.12.RELEASE.jar:5.2.12.RELEASE] ... 20 common frames omittedCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @635eaaf1 at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) ~[na:na] at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) ~[na:na] at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) ~[na:na] at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) ~[na:na] at net.sf.cglib.core.ReflectUtils$2.run(ReflectUtils.java:56) ~[cglib-3.1.jar:na] at java.base/java.security.AccessController.doPrivileged(AccessController.java:318) ~[na:na] at net.sf.cglib.core.ReflectUtils.&lt;clinit&gt;(ReflectUtils.java:46) ~[cglib-3.1.jar:na] ... 39 common frames omitted 验证分布式事务order-service中OrderService类提供了一个业务方法，里面包括了订单和库存的操作，这个业务方法上有一个@GlobalTransactional，加上这个注解表示该方法开启分布式事务，就是这么简单，这里它就是分布式事务的发起者，也叫做TM 12345678910111213141516/** * 下单：创建订单、减库存，涉及到两个服务 * * @param userId * @param commodityCode * @param count */@GlobalTransactional@Transactional(rollbackFor = Exception.class)public void placeOrder(String userId, String commodityCode, Integer count) &#123; BigDecimal orderMoney = new BigDecimal(count).multiply(new BigDecimal(5)); Order order = new Order().setUserId(userId).setCommodityCode(commodityCode).setCount(count).setMoney( orderMoney); orderDAO.insert(order); stockFeignClient.deduct(commodityCode, count);&#125; 上面stockFeignClient.deduct(commodityCode, count)这行代码调用的是stock-service服务下StockService类下的deduct方法，这里它是分布式事务的参与者，也叫做RM 12345678910111213141516171819/** * 减库存 * * @param commodityCode * @param count */@Transactional(rollbackFor = Exception.class)public void deduct(String commodityCode, int count) &#123; if (commodityCode.equals(&quot;product-2&quot;)) &#123; throw new RuntimeException(&quot;异常:模拟业务异常:stock branch exception&quot;); &#125; QueryWrapper&lt;Stock&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.setEntity(new Stock().setCommodityCode(commodityCode)); Stock stock = stockDAO.selectOne(wrapper); stock.setCount(stock.getCount() - count); stockDAO.updateById(stock);&#125; 从代码就可以看出只要commodityCode为product-2就会抛出异常，然后就会进行全局回滚，调用OrderController提供的placeOrderCommit和placeOrderRollback分别进行提交和回滚操作，当然如果你掉用的placeOrderCommit也回滚了，那可能是你数据库stock_tbl表中没有加对应的数据。"},{"title":"client端源码解析","path":"/wiki/seata/principle.html","content":"源码下载github仓库：https://github.com/seata/seata 源码下载后使用idea打开，打开后可以看到有很多目录，官方提供的Spring boot start的方式，那说明只要找到对应的spring.factories就能找到源码入口。 源码入口打开项目，可以看见seata-spring-boot-starter模块，在该模块下的resources&#x2F;META-INF可以看见一个spring.factories文件。 123456# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\io.seata.spring.boot.autoconfigure.SeataDataSourceAutoConfiguration,\\io.seata.spring.boot.autoconfigure.SeataAutoConfiguration,\\io.seata.spring.boot.autoconfigure.HttpAutoConfiguration,\\io.seata.spring.boot.autoconfigure.SeataSagaAutoConfiguration SeataAutoConfiguration其中关键的是io.seata.spring.boot.autoconfigure.SeataAutoConfiguration这一个类，在源码中找到它。 从这里可以看出主要的作用就是向ioc容器中注入了一个GlobalTransactionScanner类型的bean对象，再找到GlobalTransactionScanner类。 123456789101112131415161718192021@ConditionalOnProperty(prefix = SEATA_PREFIX, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)@AutoConfigureAfter(&#123;SeataCoreAutoConfiguration.class&#125;)public class SeataAutoConfiguration &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SeataAutoConfiguration.class); @Bean(BEAN_NAME_FAILURE_HANDLER) @ConditionalOnMissingBean(FailureHandler.class) public FailureHandler failureHandler() &#123; return new DefaultFailureHandlerImpl(); &#125; @Bean @DependsOn(&#123;BEAN_NAME_SPRING_APPLICATION_CONTEXT_PROVIDER, BEAN_NAME_FAILURE_HANDLER&#125;) @ConditionalOnMissingBean(GlobalTransactionScanner.class) public GlobalTransactionScanner globalTransactionScanner(SeataProperties seataProperties, FailureHandler failureHandler, ConfigurableListableBeanFactory beanFactory, @Autowired(required = false) List&lt;ScannerChecker&gt; scannerCheckers) &#123; // .... return new GlobalTransactionScanner(seataProperties.getApplicationId(), seataProperties.getTxServiceGroup(), failureHandler); &#125;&#125; GlobalTransactionScanner12public class GlobalTransactionScanner extends AbstractAutoProxyCreator implements ConfigurationChangeListener, InitializingBean, ApplicationContextAware, DisposableBean InitializingBean, ApplicationContextAware, DisposableBean是spring bean生命周期的内容，InitializingBean主要初始化TM和RM，DisposableBean则做一些资源销毁的任务。 GlobalTransactionScanner继承AbstractAutoProxyCreator，这是aop的一个重要组件，这里重写了它的wrapIfNecessary方法，spring中每个bean在实例化的时候都会执行这个方法，可以实现对目标对象的动态代理。 从代码中可以看出，这里会给被代理方法添加一个叫做GlobalTransactionalInterceptor（全局事务拦截器） 123456789101112131415161718192021222324@Overrideprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; // ... //check TCC proxy if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) &#123; // init tcc fence clean task if enable useTccFence TCCBeanParserUtils.initTccFenceCleanTask(TCCBeanParserUtils.getRemotingDesc(beanName), applicationContext); //TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC interceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName)); ConfigurationCache.addConfigListener(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION, (ConfigurationChangeListener)interceptor); &#125; else &#123; // ... // 主要代码 if (globalTransactionalInterceptor == null) &#123; globalTransactionalInterceptor = new GlobalTransactionalInterceptor(failureHandlerHook); ConfigurationCache.addConfigListener( ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION, (ConfigurationChangeListener)globalTransactionalInterceptor); &#125; interceptor = globalTransactionalInterceptor; &#125;// ....&#125; GlobalTransactionalInterceptor\b进入GlobalTransactionalInterceptor，既然是拦截器，那么就看它的invoke方法，这里会判断是否存在@GlobalTransactional注解或存在全局事务，有的话就会调用handleGlobalTransaction进入全局事务执行环节。 12345678910111213141516171819202122232425262728293031323334 @Overridepublic Object invoke(final MethodInvocation methodInvocation) throws Throwable &#123; Class&lt;?&gt; targetClass = methodInvocation.getThis() != null ? AopUtils.getTargetClass(methodInvocation.getThis()) : null; Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass); if (specificMethod != null &amp;&amp; !specificMethod.getDeclaringClass().equals(Object.class)) &#123; final Method method = BridgeMethodResolver.findBridgedMethod(specificMethod); final GlobalTransactional globalTransactionalAnnotation = getAnnotation(method, targetClass, GlobalTransactional.class); final GlobalLock globalLockAnnotation = getAnnotation(method, targetClass, GlobalLock.class); boolean localDisable = disable || (ATOMIC_DEGRADE_CHECK.get() &amp;&amp; degradeNum &gt;= degradeCheckAllowTimes); if (!localDisable) &#123; if (globalTransactionalAnnotation != null || this.aspectTransactional != null) &#123; AspectTransactional transactional; if (globalTransactionalAnnotation != null) &#123; transactional = new AspectTransactional(globalTransactionalAnnotation.timeoutMills(), globalTransactionalAnnotation.name(), globalTransactionalAnnotation.rollbackFor(), globalTransactionalAnnotation.rollbackForClassName(), globalTransactionalAnnotation.noRollbackFor(), globalTransactionalAnnotation.noRollbackForClassName(), globalTransactionalAnnotation.propagation(), globalTransactionalAnnotation.lockRetryInterval(), globalTransactionalAnnotation.lockRetryTimes()); &#125; else &#123; transactional = this.aspectTransactional; &#125; return handleGlobalTransaction(methodInvocation, transactional); &#125; else if (globalLockAnnotation != null) &#123; return handleGlobalLock(methodInvocation, globalLockAnnotation); &#125; &#125; &#125; return methodInvocation.proceed();&#125; 构建事务信息对象主要关注的是transactionalTemplate.execute()这个方法，这里传入的TransactionalExecutor主要目的是对事务信息对象的构建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Object handleGlobalTransaction(final MethodInvocation methodInvocation, final AspectTransactional aspectTransactional) throws Throwable &#123; boolean succeed = true; try &#123; return transactionalTemplate.execute(new TransactionalExecutor() &#123; @Override public Object execute() throws Throwable &#123; return methodInvocation.proceed(); &#125; // 获取事务名称 public String name() &#123; String name = aspectTransactional.getName(); if (!StringUtils.isNullOrEmpty(name)) &#123; return name; &#125; return formatMethod(methodInvocation.getMethod()); &#125; @Override public TransactionInfo getTransactionInfo() &#123; // reset the value of timeout int timeout = aspectTransactional.getTimeoutMills(); if (timeout &lt;= 0 || timeout == DEFAULT_GLOBAL_TRANSACTION_TIMEOUT) &#123; timeout = defaultGlobalTransactionTimeout; &#125; // 构建事务信息对象 TransactionInfo transactionInfo = new TransactionInfo(); transactionInfo.setTimeOut(timeout); transactionInfo.setName(name()); transactionInfo.setPropagation(aspectTransactional.getPropagation()); transactionInfo.setLockRetryInterval(aspectTransactional.getLockRetryInterval()); transactionInfo.setLockRetryTimes(aspectTransactional.getLockRetryTimes()); Set&lt;RollbackRule&gt; rollbackRules = new LinkedHashSet&lt;&gt;(); for (Class&lt;?&gt; rbRule : aspectTransactional.getRollbackFor()) &#123; rollbackRules.add(new RollbackRule(rbRule)); &#125; for (String rbRule : aspectTransactional.getRollbackForClassName()) &#123; rollbackRules.add(new RollbackRule(rbRule)); &#125; for (Class&lt;?&gt; rbRule : aspectTransactional.getNoRollbackFor()) &#123; rollbackRules.add(new NoRollbackRule(rbRule)); &#125; for (String rbRule : aspectTransactional.getNoRollbackForClassName()) &#123; rollbackRules.add(new NoRollbackRule(rbRule)); &#125; transactionInfo.setRollbackRules(rollbackRules); return transactionInfo; &#125; &#125;); &#125; catch (TransactionalExecutor.ExecutionException e) &#123; // ... &#125; &#125; 核心源码execute就是主要源码部分了，会先获取当前的一个全局事务id（xid），然后根据不同的事务传播行为做不同的处理，最后就是开启全局事务和提交或回滚全局事务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public Object execute(TransactionalExecutor business) throws Throwable &#123; // 1. Get transactionInfo // 获取事务信息，就是上一步方法中执行的结果 TransactionInfo txInfo = business.getTransactionInfo(); if (txInfo == null) &#123; throw new ShouldNeverHappenException(&quot;transactionInfo does not exist&quot;); &#125; // 1.1 Get current transaction, if not null, the tx role is &#x27;GlobalTransactionRole.Participant&#x27;. // 获取当前事务 GlobalTransaction tx = GlobalTransactionContext.getCurrent(); // 1.2 Handle the transaction propagation. // 下面这部分是根据不同的事务传播机制做不同的行为 Propagation propagation = txInfo.getPropagation(); SuspendedResourcesHolder suspendedResourcesHolder = null; try &#123; switch (propagation) &#123; case NOT_SUPPORTED: // If transaction is existing, suspend it. if (existingTransaction(tx)) &#123; suspendedResourcesHolder = tx.suspend(); &#125; // Execute without transaction and return. return business.execute(); case REQUIRES_NEW: // If transaction is existing, suspend it, and then begin new transaction. if (existingTransaction(tx)) &#123; suspendedResourcesHolder = tx.suspend(); tx = GlobalTransactionContext.createNew(); &#125; // Continue and execute with new transaction break; case SUPPORTS: // If transaction is not existing, execute without transaction. if (notExistingTransaction(tx)) &#123; return business.execute(); &#125; // Continue and execute with new transaction break; case REQUIRED: // If current transaction is existing, execute with current transaction, // else continue and execute with new transaction. break; case NEVER: // If transaction is existing, throw exception. if (existingTransaction(tx)) &#123; throw new TransactionException( String.format(&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;, xid = %s&quot; , tx.getXid())); &#125; else &#123; // Execute without transaction and return. return business.execute(); &#125; case MANDATORY: // If transaction is not existing, throw exception. if (notExistingTransaction(tx)) &#123; throw new TransactionException(&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;); &#125; // Continue and execute with current transaction. break; default: throw new TransactionException(&quot;Not Supported Propagation:&quot; + propagation); &#125; // 1.3 If null, create new transaction with role &#x27;GlobalTransactionRole.Launcher&#x27;. if (tx == null) &#123; tx = GlobalTransactionContext.createNew(); &#125; // set current tx config to holder GlobalLockConfig previousConfig = replaceGlobalLockConfig(txInfo); try &#123; // 2. If the tx role is &#x27;GlobalTransactionRole.Launcher&#x27;, send the request of beginTransaction to TC, // else do nothing. Of course, the hooks will still be triggered. // 开启事务 beginTransaction(txInfo, tx); Object rs; try &#123; // Do Your Business // 执行业务 rs = business.execute(); &#125; catch (Throwable ex) &#123; // 3. The needed business exception to rollback. // 如果业务发生异常，那么判断目标异常是否需要回滚，进行回滚或忽略异常 completeTransactionAfterThrowing(txInfo, tx, ex); throw ex; &#125; // 4. everything is fine, commit. // 提交事物 commitTransaction(tx); return rs; &#125; finally &#123; //5. clear // 资源清理 resumeGlobalLockConfig(previousConfig); triggerAfterCompletion(); cleanUp(); &#125; &#125; finally &#123; // If the transaction is suspended, resume it. if (suspendedResourcesHolder != null) &#123; tx.resume(suspendedResourcesHolder); &#125; &#125; &#125; 这里的开启、提交、回滚等操作其最后都是调用DefaultTransactionManager类下的syncCall方法，且都是采用netty与TCC进行通讯，开启事务时会返回一个全局事务id（xid）并绑定到本地当前事务。 数据源代理state对DataSource、Statement、Connection等都进行了代理，所以在执行语句前可以进行一些特殊的操作，比如生成前镜像和后镜像。 从SeataDataSourceAutoConfiguration类中可知数据源代理是通过SeataAutoDataSourceProxyCreator类中的操作来完成的。 （这里有点小区别，1.4.2之前的版本SeataDataSourceConfiguration是SeataAutoConfiguration类中的一个静态内部类，这个类往容器中注入了一个SeataDataSourceBeanPostProcessor类型的bean，这个bean通过在数据源bean的生命周期中去直接拦截返回数据的代理类实现代理的，而1.4.2版本则移除了这个类，目的都是完成对数据源的代理，这里展示的是1.4.2之后的版本代码） 找到SeataAutoDataSourceProxyCreator类发现它也是继承了AbstractAutoProxyCreator类来实现动态代理，那么找到重写的wrapIfNecessary方法： 123456789101112131415161718192021@Override protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; // we only care DataSource bean if (!(bean instanceof DataSource)) &#123; return bean; &#125; // when this bean is just a simple DataSource, not SeataDataSourceProxy if (!(bean instanceof SeataDataSourceProxy)) &#123; Object enhancer = super.wrapIfNecessary(bean, beanName, cacheKey); // this mean this bean is either excluded by user or had been proxy before if (bean == enhancer) &#123; return bean; &#125; // else, build proxy, put &lt;origin, proxy&gt; to holder and return enhancer DataSource origin = (DataSource) bean; SeataDataSourceProxy proxy = buildProxy(origin, dataSourceProxyMode); DataSourceProxyHolder.put(origin, proxy); return enhancer; &#125; // ... &#125; 从代码中可以看出，这里构建了一个SeataDataSourceProxy类型的数据源代理，DataSourceProxyHolder.put(origin, proxy)内部其实是一个Map&lt;DataSource, SeataDataSourceProxy&gt;类型的Map对象，用来存储原数据源对象和代理对象的关系。 另外，这里的buildProxy方法，也就是构建数据源代理对象的方法，里面根据不同的模式 构建的对象有区别，这里只说官方默认的AT模式。 1234567891011SeataDataSourceProxy buildProxy(DataSource origin, String proxyMode) &#123; if (BranchType.AT.name().equalsIgnoreCase(proxyMode)) &#123; // AT 模式构建的数据源代理对象 return new DataSourceProxy(origin); &#125; if (BranchType.XA.name().equalsIgnoreCase(proxyMode)) &#123; // XA 模式构建的数据源代理对象 return new DataSourceProxyXA(origin); &#125; throw new IllegalArgumentException(&quot;Unknown dataSourceProxyMode: &quot; + proxyMode);&#125; DataSourceProxy中通过重写getConnection方法的重新完成对Connection的代理 12345@Overridepublic ConnectionProxy getConnection() throws SQLException &#123; Connection targetConnection = targetDataSource.getConnection(); return new ConnectionProxy(this, targetConnection);&#125; ConnectionProxy类继承AbstractConnectionProxy，AbstractConnectionProxy类实现Connection接口，主要实现prepareStatement方法来实现代理PreparedStatement对象 12345@Overridepublic PreparedStatement prepareStatement(String sql) throws SQLException &#123; // ... return new PreparedStatementProxy(this, targetPreparedStatement, sql);&#125; PreparedStatementProxy代理对象对execute、executeQuery、executeUpdate等方法重写，内部都是调用的ExecuteTemplate.execute方法 1234567891011121314@Overridepublic boolean execute() throws SQLException &#123; return ExecuteTemplate.execute(this, (statement, args) -&gt; statement.execute());&#125;@Overridepublic ResultSet executeQuery() throws SQLException &#123; return ExecuteTemplate.execute(this, (statement, args) -&gt; statement.executeQuery());&#125;@Overridepublic int executeUpdate() throws SQLException &#123; return ExecuteTemplate.execute(this, (statement, args) -&gt; statement.executeUpdate());&#125; 接着看ExecuteTemplate.execute方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static &lt;T, S extends Statement&gt; T execute(List&lt;SQLRecognizer&gt; sqlRecognizers, StatementProxy&lt;S&gt; statementProxy, StatementCallback&lt;T, S&gt; statementCallback, Object... args) throws SQLException &#123; // ... if (CollectionUtils.isEmpty(sqlRecognizers)) &#123; executor = new PlainExecutor&lt;&gt;(statementProxy, statementCallback); &#125; else &#123; if (sqlRecognizers.size() == 1) &#123; SQLRecognizer sqlRecognizer = sqlRecognizers.get(0); // 根据不同的sql类型得到不同的执行器 switch (sqlRecognizer.getSQLType()) &#123; case INSERT: executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType, new Class[]&#123;StatementProxy.class, StatementCallback.class, SQLRecognizer.class&#125;, new Object[]&#123;statementProxy, statementCallback, sqlRecognizer&#125;); break; case UPDATE: executor = new UpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer); break; case DELETE: executor = new DeleteExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer); break; case SELECT_FOR_UPDATE: executor = new SelectForUpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer); break; case INSERT_ON_DUPLICATE_UPDATE: switch (dbType) &#123; case JdbcConstants.MYSQL: case JdbcConstants.MARIADB: executor = new MySQLInsertOnDuplicateUpdateExecutor(statementProxy, statementCallback, sqlRecognizer); break; default: throw new NotSupportYetException(dbType + &quot; not support to INSERT_ON_DUPLICATE_UPDATE&quot;); &#125; break; default: // 普通执行器 executor = new PlainExecutor&lt;&gt;(statementProxy, statementCallback); break; &#125; &#125; else &#123; executor = new MultiExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizers); &#125; &#125; T rs; try &#123; // 调用执行方法 rs = executor.execute(args); &#125; catch (Throwable ex) &#123; if (!(ex instanceof SQLException)) &#123; // Turn other exception into SQLException ex = new SQLException(ex); &#125; throw (SQLException) ex; &#125; return rs; &#125; 进入executor.execute(args)找到实现类BaseTransactionalExecutor再进入doExecute方法，再找到doExecute的在AbstractDMLBaseExecutor中的实现方法 AbstractDMLBaseExecutor中有两个分支，自动提交事务和手动提交事务，其实自动提交事务后面也会改成手动，不过它内部有提交逻辑 1234567891011@Overridepublic T doExecute(Object... args) throws Throwable &#123; AbstractConnectionProxy connectionProxy = statementProxy.getConnectionProxy(); if (connectionProxy.getAutoCommit()) &#123; // 执行自动提交事务逻辑 return executeAutoCommitTrue(args); &#125; else &#123; // 执行手动提交事务逻辑 return executeAutoCommitFalse(args); &#125;&#125; 进入executeAutoCommitTrue 123456789101112131415161718192021222324protected T executeAutoCommitTrue(Object[] args) throws Throwable &#123; ConnectionProxy connectionProxy = statementProxy.getConnectionProxy(); try &#123; // 将事务提交方式设置为手动 connectionProxy.changeAutoCommit(); return new LockRetryPolicy(connectionProxy).execute(() -&gt; &#123; // 执行手动提交事务的逻辑，这里很重要，AT模式的undolog就是在此时产生 T result = executeAutoCommitFalse(args); // 提交事务 connectionProxy.commit(); return result; &#125;); &#125; catch (Exception e) &#123; // when exception occur in finally,this exception will lost, so just print it here LOGGER.error(&quot;execute executeAutoCommitTrue error:&#123;&#125;&quot;, e.getMessage(), e); if (!LockRetryPolicy.isLockRetryPolicyBranchRollbackOnConflict()) &#123; connectionProxy.getTargetConnection().rollback(); &#125; throw e; &#125; finally &#123; connectionProxy.getContext().reset(); connectionProxy.setAutoCommit(true); &#125;&#125; 产生UndoLog进入executeAutoCommitFalse方法，这里会在语句执行之前产生一个前镜像，在执行之后产生一个后镜像其实就是记录执行前后的区别，然后根据他们来形成undoLog用于后续可能的数据回滚，这里的undolog只是存在缓存中，暂时没有持久化到db 1234567891011protected T executeAutoCommitFalse(Object[] args) throws Exception &#123; // 前镜像 TableRecords beforeImage = beforeImage(); // 执行语句 T result = statementCallback.execute(statementProxy.getTargetStatement(), args); // 后镜像 TableRecords afterImage = afterImage(beforeImage); // 形成undoLog暂存缓存 prepareUndoLog(beforeImage, afterImage); return result;&#125; 回到上一步，执行完executeAutoCommitFalse之后，执行connectionProxy.commit()进入事务提交环节 123456789101112131415161718 @Overridepublic void commit() throws SQLException &#123; try &#123; lockRetryPolicy.execute(() -&gt; &#123; // 具体提交事务逻辑 doCommit(); return null; &#125;); &#125; catch (SQLException e) &#123; if (targetConnection != null &amp;&amp; !getAutoCommit() &amp;&amp; !getContext().isAutoCommitChanged()) &#123; // 异常回滚 rollback(); &#125; throw e; &#125; catch (Exception e) &#123; throw new SQLException(e); &#125;&#125; 进入doCommit() 12345678910private void doCommit() throws SQLException &#123; if (context.inGlobalTransaction()) &#123; // 处理全局事务 processGlobalTransactionCommit(); &#125; else if (context.isGlobalLockRequire()) &#123; processLocalCommitWithGlobalLocks(); &#125; else &#123; targetConnection.commit(); &#125;&#125; 进入processGlobalTransactionCommit()，这里将undoLog真正持久化到db保存起来，然后执行targetConnection.commit();提交事务到数据库，提交成功与否都会通知服务端（TCC） 1234567891011121314151617181920212223private void processGlobalTransactionCommit() throws SQLException &#123; try &#123; register(); &#125; catch (TransactionException e) &#123; recognizeLockKeyConflictException(e, context.buildLockKeys()); &#125; try &#123; // 将undoLog持久化到db UndoLogManagerFactory.getUndoLogManager(this.getDbType()).flushUndoLogs(this); // 提交事务 targetConnection.commit(); &#125; catch (Throwable ex) &#123; LOGGER.error(&quot;process connectionProxy commit error: &#123;&#125;&quot;, ex.getMessage(), ex); // 发生异常，上报TCC事务执行失败，进行回滚 report(false); throw new SQLException(ex); &#125; if (IS_REPORT_SUCCESS_ENABLE) &#123; // 上报TCC事务执行成功 report(true); &#125; context.reset();&#125;"}]